前端测试 



## jest框架

- 速度快
- API简单
- 易配置 
- 隔离性好
- 监控模式
- IDE整合
- Snapshot
- 多项目并存  比如 node和react一起跑
- 覆盖率
- mock丰富



test、expect 、 toBe原理

```javascript
function expect(result) {
  return {
    tobe: function(actual) {
      if (result !== actual) {
        throw new Error(`测试失败 expect:${result},actual:${actual}`);
      }
    }
  };
}

function test(desc, fn) {
  try {
    fn();
    console.log('测试通过', desc);
  } catch (error) {
    console.log('测试失败', error);
  }
}
```



## 使用jest



npx jest --init

npx jest --coverage



使用es6语法

npm i @bable/core@7.4.5 @babel/preset-env@7.4.5 -D



创建：.babelrc 文件

```javascript
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "node": true
        }
      }
    ]
  ]
}

```

如果配置了babel

npm run jest

jest  会默认 babel-jest

取.babelrc配置

在使用 jest时，默认会调用 babel进行语法转换



npx jest --watchAll

npx jest --watch  默认是o选项 也就是只对当前更改的测试文件进行监听，重新跑测试。



## 匹配器

-  toBe 是完全相等，对于对象是引用
-  toEqual是内容相等，如果是两个对象，则比较里面的属性值，而不是引用
-  toMatchObject 断言和返回的对象属性匹配
-  toBeCloseTo 接近于0.3 。比如 0.1+0.2 是不等于0.3的
-  toThrow 断言必须抛出异常



## 异步代码的测试

- 在test方法中 return Promise
- 在test方法里面，调用done
- expect.assertions(1)  至少要有一次断言。



```javascript
import { fetchData, fetchData2 } from './api';

test('应该成功', () => {
  return fetchData().then(res => {
    expect(res.data).toEqual({
      success: true
    });
  });
});

test('应该404', () => {
  expect.assertions(1);
  return fetchData2().catch(e => {
    expect(e.message).toMatch('404');
  });
});

```

另一种语法：

```javascript
test('应该成功resolves', () => {
  return expect(fetchData()).resolves.toMatchObject({
    data: {
      success: true
    }
  });
});
test('应该404', () => {
  return expect(fetchData2()).rejects.toThrow();
});
```



推荐await async

```javascript
test('await 形式应该成功', async () => {
  const response = await fetchData();
  expect(response.data).toEqual({
    success: true
  });
});
```



## jest 钩子函数

- beforeAll
- beforeEach
- test
- afterEach
- afterAll

分组 ：

describe("测试第一组",()=>{

});

需要注意的是分组之后的beforeAll，等这些狗子函数是由作用域 的。



技巧：

可以暂时只跑这一个测试用，跳过其他的测试 。

```javascript
test.only("test",()=>{

})
```

公共代码尽量放在 钩子函数中执行 。



## Mock

三个作用 :

1. 捕获函数的调用和返回结果，以及this和返回值
2. 可以让我们自由的mock函数返回结果
3. 改变函数的内部实现 `axios.get.mockResolvedValue`,`jest.fn().mockImplementation`

```javascript
const func = jest.fn();// 生成一个 mock 函数 

runCallback(fuc);
expect(func.mock.calls.length).toBe(3);// 验证函数被调用了3次

expect(func).toBeCalled();// 验证是否被 调用
console.log(func.mock);
```



```javascript
const func = jest.fn();
func.mockReturnValueOnce("one");//  第一次返回结果
func.mockReturnValueOnce("two");//  mock的第二次函数被调用返回结果
```



```javascript
jest.mock('axios');
test("mock axios",async ()=>{	
    axios.get.mockResolvedValue({ data:"Hello" });	
        await  getData().then(()=>{
            expect(data).toBe("Hello");
        })
})
```



## 插件

jest

可以替代我们run test




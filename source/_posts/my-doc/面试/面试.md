# 基础知识和常考



## 6个 原始类型

- object
- null
- undefined
- number
- string
- Symbol



## `typeof` vs `instanceof`

`typeof` 对于原始类型来说，除了 `null` 都可以显示正确的类型

对象类型细分：

- Array
- Date
- Function
- Reg 

这些可以通过 `Object.prototype.toString.call(obj) === "[object Date]"`来识别



> `instanceof `的原理是什么？

遍历原型链

`[Symbol.hasInstance]`的优先级高





## 类型转换

js中类型转换只有三种情况：

- 转换为布尔值

  除了 `undefined`， `null`， `false`， `NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象。

- 转换为数字.

  逻辑：`[[ToPrimitive]]`优先级最高。

  `[[ToPrimitive]]` -> `.valueOf()`

- 转换为字符串

  都是调用类型的 `toString()`;



### 四则运算符

加法：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
```



### 比较运算符

1. 如果是对象，就通过 `toPrimitive` 转换对象
2. 如果是字符串，就通过 `unicode` 字符索引来比较

## this

> 涉及面试题：如何正确判断 this？箭头函数的 this 是什么？



## == vs ===  区别？

## 闭包

涉及面试题：什么是闭包？

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

经典面试题，循环中使用闭包解决 `var` 定义函数的问题

## 深浅拷贝

涉及面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？

### 浅拷贝

### 深拷贝

## 原型

涉及面试题：如何理解原型？如何理解原型链？





# ES6 知识

## var、let 及 const 区别

- 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部
- `var` 存在提升，我们能在声明之前使用。`let`、`const` 因为暂时性死区的原因，不能在声明前使用
- `var` 在全局作用域下声明变量会导致变量挂载在 `window` 上，其他两者不会
- `let` 和 `const` 作用基本一致，但是后者声明的变量不能再次赋值

## 继承

> 涉及面试题：原型如何实现继承？Class 如何实现继承？Class 本质是什么？

### 组合继承

```
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)
```



核心是在子类的构造函数中通过 `Parent.call(this)` 继承父类的属性，然后改变子类的原型为 `new Parent()` 来继承父类的函数。



### 寄生组合继承

```
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)
```

核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数

### Class 继承

ES6的语法

## 模块化

> 涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

### 立即执行函数

### `AMD 和 CMD`

```
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
```



### `CommonJS`

CommonJS 最早是 Node 在使用

### ES Module



- CommonJS 支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案
- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 `require/exports` 来执行的



## Proxy

> 涉及面试题：Proxy 可以实现什么功能？

- 性能更好
- 支持动态添加属性
- 支持数组

## map, filter, reduce





## JS 异步编程

### 并发（concurrency）和并行（parallelism）区别

> 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
> 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
> 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
>
> 并发的关键是你有处理多个任务的能力，不一定要同时。
> 并行的关键是你有同时处理多个任务的能力。
>
> 所以我认为它们最关键的点就是：是否是『同时』。
>
> 
>
> 作者：「已注销」
> 链接：https://www.zhihu.com/question/33515481/answer/58849148

### 回调函数（Callback）

### Generator



参考

https://es6.ruanyifeng.com/#docs/generator

### Promise

涉及面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？

手写promise

> 涉及面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？



### `async` 及 `await`

> 涉及面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？需要注意什么问题？

`async` 就是将函数返回值使用 `Promise.resolve()` 包裹了下，和 `then` 中处理返回值一样，并且 `await` 只能配套 `async` 使用



[async-函数的实现原理]([https://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86](https://es6.ruanyifeng.com/#docs/async#async-函数的实现原理))





### 常用定时器函数

> 涉及面试题：`setTimeout`、`setInterval`、`requestAnimationFrame` 各有什么特点？

- `setTimeout`

  因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行。

- `setInterval` 同上

- `requestAnimationFrame` 

  首先 `requestAnimationFrame` 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的





### Event Loop

> 涉及面试题：进程与线程区别？JS 单线程带来的好处？





- 参考

  [阮一峰](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

  [小册](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7198518825171726cfce)

  

# JS 进阶知识点

涉及面试题：call、apply 及 bind 函数内部实现是怎么样的？



## `new`的原理



## `instanceof `的原理

## 为什么 0.1 + 0.2 != 0.3

## 垃圾回收机制

- 新生代算法

- 老生代算法



# 总结

思考：在回答面试官的一些问题时，如果每个问题你都能引申出一些相关联的知识点，那么面试官一定会提高对你的评价。

思考题一：JS 分为哪两大类型？都有什么各自的特点？你该如何判断正确的类型？





思考题二：你理解的原型是什么？



思考题三：bind、call 和 apply 各自有什么区别？

思考题四：ES6 中有使用过什么？

思考题五：JS 是如何运行的？









